package org.lemon.jvmstudy.classloader;

/**
 * @author lemon
 * @version 1.0.0
 * @Description TODO
 * @createTime 2020年05月03日 16:30:00
 */
public class MyClassLoader extends ClassLoader{


    /**
     *
     * b2c抓取的代码中是通过urlclassload去加载最新的class文件, 然后将之前的class文件给删除掉，这个功能如何实现的， 相当于热部署是如何实现的
     *
     * 之前想实现一个日志功能，动态的给class文件去加注解，然后实现对应的功能，最后是失败了，
     *
     * 再次深入的理解 动态的修改字节码文件的jar包的作用， 在tomcat环境下，
     *
     * 命名空间的作用
     *
     * classNotFoundException与 NoClassDefFoundError的区别是什么
     *
     * tomcat的类加载机制的什么样的？？？？？？？？？
     *
     * =================================================================================================
     *
     *
     * 子加载器是能看到父加载器所加载的类，反过来，父加载器是看不到子加载器所加载的类
     *
     * 类加载器的双亲委托机制的好处
     *
     *
     * 1、可以确保java核心库的类型安全： 所有的java应用都至少会引用java.lang.object类，也就是说再运行期，java.lang.Object这个类会被
     * 加载到java虚拟机中，如果这个加载过程是由java应用自己的类加载器去加载的话，那么很可能就会在jvm中存在多个版本的Object类，而且这些类
     * 之间是不兼容的，相互不可见
     *
     * 2、可以确保java核心 类库多提供的类不会被自定义的类所代替
     *
     * 3、同步的类加载器可以为不同名称的类创建额外的命名空间，相同名称的类可以并存在java虚拟机中，只需要用不同的类加载器来加载他们即可，不同类
     * 加载器所加载的类之间是不兼容的，这就相当于在java虚拟机内部创建了一个又一个相互隔离的java类空间，这类技术在很多框架中都得到了实际应用
     *
     * 扩展类加载器只加载jar文件，不加载class文件
     *
     *
     * 类加载器本身是怎么加载的？
     *
     * 扩展类加载器和应用类加载器是由启动类加载器来加载的， 启动类加载器是由c++编写的，
     *
     * 内建于jvm中的启动类加载器会加载java.lang.classLoader以及其他的java平台类
     * 当jvm启动时，一块特殊的机器码会运行，它会加载扩展类加载器与系统类加载器
     *  这块特殊的机器码叫做启动类加载器bootstrap
     *
     *  启动类加载器并不是java类，而其他的加载器则是Java类
     *  启动类加载器是特定于平台的机器指令，它负责开启整个加载过程
     *
     *  所有类加载器（除了启动类加载器） 都被实现为java类，不过，终归要有一个组件来加载第一个java类加载器，从而让整个加载过程能够顺利进行下去，
     *  加载第一个纯java类加载器就是启动类加载器的职责
     *
     *  启动类加载器还会负责加载供jre正常运行所需要的基本组件，这包括java.util与java.lang包的类等等
     *
     *
     *
     */


}
